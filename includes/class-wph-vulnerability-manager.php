<?php
/**
 * Vulnerability Manager Class
 *
 * @package WP_Harden
 * @since 1.0.0
 */

// If this file is called directly, abort.
if ( ! defined( 'WPINC' ) ) {
	die;
}

/**
 * Class WPH_Vulnerability_Manager
 *
 * Manages vulnerability scanning and security updates
 */
class WPH_Vulnerability_Manager {

	/**
	 * Singleton instance
	 *
	 * @var WPH_Vulnerability_Manager
	 */
	private static $instance = null;

	/**
	 * Table name for vulnerabilities
	 *
	 * @var string
	 */
	private $vuln_table;

	/**
	 * WPScan API endpoint
	 *
	 * @var string
	 */
	private $api_endpoint = 'https://wpscan.com/api/v3/';

	/**
	 * API cache duration
	 *
	 * @var int
	 */
	private $cache_duration = 86400; // 24 hours

	/**
	 * Get singleton instance
	 *
	 * @return WPH_Vulnerability_Manager
	 * @since 1.0.0
	 */
	public static function get_instance() {
		if ( null === self::$instance ) {
			self::$instance = new self();
		}
		return self::$instance;
	}

	/**
	 * Constructor
	 *
	 * @since 1.0.0
	 */
	private function __construct() {
		global $wpdb;
		$this->vuln_table = $wpdb->prefix . 'wph_vulnerabilities';
		$this->init_hooks();
	}

	/**
	 * Initialize hooks
	 *
	 * @since 1.0.0
	 */
	private function init_hooks() {
		add_action( 'wph_daily_vulnerability_scan', array( $this, 'scan_all_components' ) );
		add_action( 'auto_update_plugin', array( $this, 'log_auto_update' ), 10, 2 );
		add_action( 'auto_update_theme', array( $this, 'log_auto_update' ), 10, 2 );
		
		// Enable auto-updates filters
		add_filter( 'auto_update_plugin', array( $this, 'filter_plugin_auto_updates' ), 10, 2 );
		add_filter( 'auto_update_theme', array( $this, 'filter_theme_auto_updates' ), 10, 2 );
	}

	/**
	 * Create vulnerabilities table
	 *
	 * @since 1.0.0
	 */
	public function create_table() {
		global $wpdb;
		
		$charset_collate = $wpdb->get_charset_collate();
		
		$sql = "CREATE TABLE IF NOT EXISTS {$this->vuln_table} (
			id bigint(20) NOT NULL AUTO_INCREMENT,
			component_type varchar(20) NOT NULL,
			component_slug varchar(255) NOT NULL,
			component_version varchar(50) NOT NULL,
			vulnerability_title varchar(255) NOT NULL,
			cve_id varchar(50) DEFAULT NULL,
			severity varchar(20) NOT NULL,
			fixed_in varchar(50) DEFAULT NULL,
			discovered_at datetime NOT NULL,
			is_fixed tinyint(1) DEFAULT 0,
			PRIMARY KEY (id),
			KEY component_slug (component_slug(191)),
			KEY severity (severity),
			KEY is_fixed (is_fixed)
		) $charset_collate;";
		
		require_once ABSPATH . 'wp-admin/includes/upgrade.php';
		dbDelta( $sql );
	}

	/**
	 * Check WordPress core vulnerabilities
	 *
	 * @return array|WP_Error Vulnerabilities or error
	 * @since 1.0.0
	 */
	public function check_wordpress_vulnerabilities() {
		global $wp_version;
		
		$cache_key = 'wph_wp_vulns_' . $wp_version;
		$cached = get_transient( $cache_key );
		
		if ( false !== $cached ) {
			return $cached;
		}
		
		$settings = WPH_Settings::get_instance();
		$api_key = $settings->get( 'wpscan_api_key', '' );
		
		if ( empty( $api_key ) ) {
			return new WP_Error( 'no_api_key', 'WPScan API key not configured' );
		}
		
		$endpoint = $this->api_endpoint . 'wordpresses/' . $wp_version;
		
		$response = wp_remote_get( $endpoint, array(
			'headers' => array(
				'Authorization' => 'Token token=' . $api_key,
			),
			'timeout' => 15,
		) );
		
		if ( is_wp_error( $response ) ) {
			return $response;
		}
		
		$body = wp_remote_retrieve_body( $response );
		$data = json_decode( $body, true );
		
		if ( empty( $data ) || ! isset( $data[ $wp_version ] ) ) {
			$result = array();
		} else {
			$result = $this->parse_vulnerabilities( $data[ $wp_version ], 'wordpress', $wp_version, $wp_version );
		}
		
		set_transient( $cache_key, $result, $this->cache_duration );
		
		return $result;
	}

	/**
	 * Check plugin vulnerabilities
	 *
	 * @param string $plugin_slug Plugin slug.
	 * @param string $version     Plugin version.
	 * @return array|WP_Error Vulnerabilities or error
	 * @since 1.0.0
	 */
	public function check_plugin_vulnerabilities( $plugin_slug, $version ) {
		$cache_key = 'wph_plugin_vulns_' . md5( $plugin_slug . $version );
		$cached = get_transient( $cache_key );
		
		if ( false !== $cached ) {
			return $cached;
		}
		
		$settings = WPH_Settings::get_instance();
		$api_key = $settings->get( 'wpscan_api_key', '' );
		
		if ( empty( $api_key ) ) {
			return new WP_Error( 'no_api_key', 'WPScan API key not configured' );
		}
		
		$endpoint = $this->api_endpoint . 'plugins/' . $plugin_slug;
		
		$response = wp_remote_get( $endpoint, array(
			'headers' => array(
				'Authorization' => 'Token token=' . $api_key,
			),
			'timeout' => 15,
		) );
		
		if ( is_wp_error( $response ) ) {
			return $response;
		}
		
		$body = wp_remote_retrieve_body( $response );
		$data = json_decode( $body, true );
		
		if ( empty( $data ) || ! isset( $data[ $plugin_slug ] ) ) {
			$result = array();
		} else {
			$result = $this->parse_vulnerabilities( $data[ $plugin_slug ], 'plugin', $plugin_slug, $version );
		}
		
		set_transient( $cache_key, $result, $this->cache_duration );
		
		return $result;
	}

	/**
	 * Check theme vulnerabilities
	 *
	 * @param string $theme_slug Theme slug.
	 * @param string $version    Theme version.
	 * @return array|WP_Error Vulnerabilities or error
	 * @since 1.0.0
	 */
	public function check_theme_vulnerabilities( $theme_slug, $version ) {
		$cache_key = 'wph_theme_vulns_' . md5( $theme_slug . $version );
		$cached = get_transient( $cache_key );
		
		if ( false !== $cached ) {
			return $cached;
		}
		
		$settings = WPH_Settings::get_instance();
		$api_key = $settings->get( 'wpscan_api_key', '' );
		
		if ( empty( $api_key ) ) {
			return new WP_Error( 'no_api_key', 'WPScan API key not configured' );
		}
		
		$endpoint = $this->api_endpoint . 'themes/' . $theme_slug;
		
		$response = wp_remote_get( $endpoint, array(
			'headers' => array(
				'Authorization' => 'Token token=' . $api_key,
			),
			'timeout' => 15,
		) );
		
		if ( is_wp_error( $response ) ) {
			return $response;
		}
		
		$body = wp_remote_retrieve_body( $response );
		$data = json_decode( $body, true );
		
		if ( empty( $data ) || ! isset( $data[ $theme_slug ] ) ) {
			$result = array();
		} else {
			$result = $this->parse_vulnerabilities( $data[ $theme_slug ], 'theme', $theme_slug, $version );
		}
		
		set_transient( $cache_key, $result, $this->cache_duration );
		
		return $result;
	}

	/**
	 * Scan all components for vulnerabilities
	 *
	 * @return array Scan results
	 * @since 1.0.0
	 */
	public function scan_all_components() {
		$results = array(
			'wordpress' => array(),
			'plugins'   => array(),
			'themes'    => array(),
		);
		
		// Check WordPress core
		$wp_vulns = $this->check_wordpress_vulnerabilities();
		if ( ! is_wp_error( $wp_vulns ) ) {
			$results['wordpress'] = $wp_vulns;
			$this->store_vulnerabilities( $wp_vulns );
		}
		
		// Check plugins
		if ( ! function_exists( 'get_plugins' ) ) {
			require_once ABSPATH . 'wp-admin/includes/plugin.php';
		}
		
		$plugins = get_plugins();
		foreach ( $plugins as $plugin_file => $plugin_data ) {
			$plugin_slug = dirname( $plugin_file );
			if ( '.' === $plugin_slug ) {
				$plugin_slug = basename( $plugin_file, '.php' );
			}
			
			$vulns = $this->check_plugin_vulnerabilities( $plugin_slug, $plugin_data['Version'] );
			if ( ! is_wp_error( $vulns ) && ! empty( $vulns ) ) {
				$results['plugins'][ $plugin_slug ] = $vulns;
				$this->store_vulnerabilities( $vulns );
			}
			
			// Rate limiting
			usleep( 500000 ); // 0.5 second delay between requests
		}
		
		// Check themes
		$themes = wp_get_themes();
		foreach ( $themes as $theme_slug => $theme_obj ) {
			$vulns = $this->check_theme_vulnerabilities( $theme_slug, $theme_obj->get( 'Version' ) );
			if ( ! is_wp_error( $vulns ) && ! empty( $vulns ) ) {
				$results['themes'][ $theme_slug ] = $vulns;
				$this->store_vulnerabilities( $vulns );
			}
			
			// Rate limiting
			usleep( 500000 ); // 0.5 second delay between requests
		}
		
		// Send notification if vulnerabilities found
		$total_vulns = count( $results['wordpress'] ) + count( $results['plugins'] ) + count( $results['themes'] );
		if ( $total_vulns > 0 ) {
			$this->send_vulnerability_alert( $results );
		}
		
		return $results;
	}

	/**
	 * Get stored vulnerabilities
	 *
	 * @param string $component_type Component type (wordpress, plugin, theme).
	 * @param bool   $unfixed_only   Return only unfixed vulnerabilities.
	 * @return array Vulnerabilities
	 * @since 1.0.0
	 */
	public function get_vulnerabilities( $component_type = '', $unfixed_only = true ) {
		global $wpdb;
		
		$where = array( '1=1' );
		
		if ( ! empty( $component_type ) ) {
			$where[] = $wpdb->prepare( 'component_type = %s', $component_type );
		}
		
		if ( $unfixed_only ) {
			$where[] = 'is_fixed = 0';
		}
		
		$sql = "SELECT * FROM {$this->vuln_table} WHERE " . implode( ' AND ', $where ) . ' ORDER BY severity DESC, discovered_at DESC';
		
		return $wpdb->get_results( $sql, ARRAY_A );
	}

	/**
	 * Check if component is outdated
	 *
	 * @param string $last_updated Last update date.
	 * @return bool True if outdated
	 * @since 1.0.0
	 */
	public function is_outdated( $last_updated ) {
		if ( empty( $last_updated ) ) {
			return true;
		}
		
		$two_years_ago = strtotime( '-2 years' );
		$last_update_time = strtotime( $last_updated );
		
		return $last_update_time < $two_years_ago;
	}

	/**
	 * Enable auto-updates for component
	 *
	 * @param string $component_type Component type (plugin, theme).
	 * @param string $slug           Component slug.
	 * @return bool Success
	 * @since 1.0.0
	 */
	public function enable_auto_updates( $component_type, $slug ) {
		$auto_updates = get_option( 'wph_auto_updates', array() );
		
		if ( ! isset( $auto_updates[ $component_type ] ) ) {
			$auto_updates[ $component_type ] = array();
		}
		
		if ( ! in_array( $slug, $auto_updates[ $component_type ], true ) ) {
			$auto_updates[ $component_type ][] = $slug;
		}
		
		return update_option( 'wph_auto_updates', $auto_updates );
	}

	/**
	 * Disable auto-updates for component
	 *
	 * @param string $component_type Component type (plugin, theme).
	 * @param string $slug           Component slug.
	 * @return bool Success
	 * @since 1.0.0
	 */
	public function disable_auto_updates( $component_type, $slug ) {
		$auto_updates = get_option( 'wph_auto_updates', array() );
		
		if ( ! isset( $auto_updates[ $component_type ] ) ) {
			return true;
		}
		
		$key = array_search( $slug, $auto_updates[ $component_type ], true );
		if ( false !== $key ) {
			unset( $auto_updates[ $component_type ][ $key ] );
		}
		
		return update_option( 'wph_auto_updates', $auto_updates );
	}

	/**
	 * Get auto-update status
	 *
	 * @return array Auto-update configuration
	 * @since 1.0.0
	 */
	public function get_update_status() {
		$status = array(
			'core_updates' => get_option( 'auto_update_core_minor', true ),
			'plugins'      => get_option( 'wph_auto_updates', array() ),
		);
		
		return $status;
	}

	/**
	 * Filter plugin auto-updates
	 *
	 * @param bool   $update Whether to update.
	 * @param object $item   Update object.
	 * @return bool
	 * @since 1.0.0
	 */
	public function filter_plugin_auto_updates( $update, $item ) {
		$auto_updates = get_option( 'wph_auto_updates', array() );
		
		if ( ! isset( $auto_updates['plugin'] ) ) {
			return $update;
		}
		
		$plugin_slug = isset( $item->slug ) ? $item->slug : '';
		
		if ( in_array( $plugin_slug, $auto_updates['plugin'], true ) ) {
			return true;
		}
		
		return $update;
	}

	/**
	 * Filter theme auto-updates
	 *
	 * @param bool   $update Whether to update.
	 * @param object $item   Update object.
	 * @return bool
	 * @since 1.0.0
	 */
	public function filter_theme_auto_updates( $update, $item ) {
		$auto_updates = get_option( 'wph_auto_updates', array() );
		
		if ( ! isset( $auto_updates['theme'] ) ) {
			return $update;
		}
		
		$theme_slug = isset( $item->theme ) ? $item->theme : '';
		
		if ( in_array( $theme_slug, $auto_updates['theme'], true ) ) {
			return true;
		}
		
		return $update;
	}

	/**
	 * Log auto-update
	 *
	 * @param object $item   Update object.
	 * @param array  $result Update result.
	 * @since 1.0.0
	 */
	public function log_auto_update( $item, $result ) {
		$logger = WPH_Logger::get_instance();
		
		$logger->log(
			'auto_update',
			'low',
			'Component auto-updated',
			array(
				'item'   => $item,
				'result' => $result,
			)
		);
	}

	/**
	 * Parse vulnerabilities from API response
	 *
	 * @param array  $data           API response data.
	 * @param string $component_type Component type.
	 * @param string $component_slug Component slug.
	 * @param string $version        Current version.
	 * @return array Parsed vulnerabilities
	 * @since 1.0.0
	 */
	private function parse_vulnerabilities( $data, $component_type, $component_slug, $version ) {
		$vulnerabilities = array();
		
		if ( ! isset( $data['vulnerabilities'] ) ) {
			return $vulnerabilities;
		}
		
		foreach ( $data['vulnerabilities'] as $vuln ) {
			$fixed_in = isset( $vuln['fixed_in'] ) ? $vuln['fixed_in'] : null;
			
			// Check if current version is affected
			if ( $fixed_in && version_compare( $version, $fixed_in, '>=' ) ) {
				continue; // Already fixed in current version
			}
			
			$vulnerabilities[] = array(
				'component_type'       => $component_type,
				'component_slug'       => $component_slug,
				'component_version'    => $version,
				'vulnerability_title'  => isset( $vuln['title'] ) ? $vuln['title'] : 'Unknown vulnerability',
				'cve_id'               => isset( $vuln['references']['cve'] ) ? $vuln['references']['cve'][0] : null,
				'severity'             => $this->normalize_severity( isset( $vuln['severity'] ) ? $vuln['severity'] : 'medium' ),
				'fixed_in'             => $fixed_in,
				'discovered_at'        => current_time( 'mysql' ),
				'is_fixed'             => 0,
			);
		}
		
		return $vulnerabilities;
	}

	/**
	 * Store vulnerabilities in database
	 *
	 * @param array $vulnerabilities Vulnerabilities to store.
	 * @return bool Success
	 * @since 1.0.0
	 */
	private function store_vulnerabilities( $vulnerabilities ) {
		global $wpdb;
		
		foreach ( $vulnerabilities as $vuln ) {
			// Check if already exists
			$existing = $wpdb->get_var( $wpdb->prepare(
				"SELECT id FROM {$this->vuln_table}
				WHERE component_slug = %s
				AND vulnerability_title = %s
				AND component_version = %s",
				$vuln['component_slug'],
				$vuln['vulnerability_title'],
				$vuln['component_version']
			) );
			
			if ( ! $existing ) {
				$wpdb->insert( $this->vuln_table, $vuln );
			}
		}
		
		return true;
	}

	/**
	 * Normalize severity level
	 *
	 * @param string $severity Severity from API.
	 * @return string Normalized severity
	 * @since 1.0.0
	 */
	private function normalize_severity( $severity ) {
		$severity_map = array(
			'low'      => 'low',
			'medium'   => 'medium',
			'high'     => 'high',
			'critical' => 'critical',
		);
		
		$severity = strtolower( $severity );
		
		return isset( $severity_map[ $severity ] ) ? $severity_map[ $severity ] : 'medium';
	}

	/**
	 * Send vulnerability alert
	 *
	 * @param array $vulnerabilities Vulnerabilities found.
	 * @since 1.0.0
	 */
	private function send_vulnerability_alert( $vulnerabilities ) {
		$notifications = WPH_Notifications::get_instance();
		$settings = WPH_Settings::get_instance();
		
		$total = count( $vulnerabilities['wordpress'] ) + 
		         count( $vulnerabilities['plugins'] ) + 
		         count( $vulnerabilities['themes'] );
		
		$message = sprintf(
			'Vulnerability scan found %d security issues requiring attention.',
			$total
		);
		
		$metadata = array(
			'vulnerabilities' => $vulnerabilities,
			'scan_time'       => current_time( 'mysql' ),
		);
		
		// Log the event
		$logger = WPH_Logger::get_instance();
		$logger->log( 'vulnerability', 'high', $message, $metadata );
		
		// Send email notification
		if ( $settings->get( 'email_notifications', true ) ) {
			$to = $settings->get( 'notification_email', get_option( 'admin_email' ) );
			$subject = sprintf(
				'[%s] Security Alert: Vulnerabilities Detected',
				get_bloginfo( 'name' )
			);
			
			$body = $this->format_vulnerability_email( $vulnerabilities );
			$headers = array( 'Content-Type: text/html; charset=UTF-8' );
			
			wp_mail( $to, $subject, $body, $headers );
		}
	}

	/**
	 * Format vulnerability email
	 *
	 * @param array $vulnerabilities Vulnerabilities data.
	 * @return string HTML email body
	 * @since 1.0.0
	 */
	private function format_vulnerability_email( $vulnerabilities ) {
		ob_start();
		?>
		<!DOCTYPE html>
		<html>
		<head>
			<meta charset="UTF-8">
			<style>
				body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
				.container { max-width: 600px; margin: 0 auto; padding: 20px; }
				.header { background: #dc3232; color: white; padding: 20px; text-align: center; }
				.vuln { padding: 15px; margin: 10px 0; border-left: 4px solid #dc3232; background: #f9f9f9; }
				.severity { font-weight: bold; padding: 3px 8px; border-radius: 3px; display: inline-block; }
				.severity.critical { background: #dc3232; color: white; }
				.severity.high { background: #ffb900; color: white; }
				.severity.medium { background: #0073aa; color: white; }
				.severity.low { background: #46b450; color: white; }
				.footer { margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd; text-align: center; color: #666; }
			</style>
		</head>
		<body>
			<div class="container">
				<div class="header">
					<h1>⚠️ Vulnerabilities Detected</h1>
					<p><?php echo esc_html( get_bloginfo( 'name' ) ); ?></p>
				</div>
				
				<?php if ( ! empty( $vulnerabilities['wordpress'] ) ) : ?>
				<h2>WordPress Core</h2>
				<?php foreach ( $vulnerabilities['wordpress'] as $vuln ) : ?>
				<div class="vuln">
					<span class="severity <?php echo esc_attr( $vuln['severity'] ); ?>">
						<?php echo esc_html( strtoupper( $vuln['severity'] ) ); ?>
					</span>
					<h3><?php echo esc_html( $vuln['vulnerability_title'] ); ?></h3>
					<?php if ( ! empty( $vuln['cve_id'] ) ) : ?>
						<p><strong>CVE:</strong> <?php echo esc_html( $vuln['cve_id'] ); ?></p>
					<?php endif; ?>
					<?php if ( ! empty( $vuln['fixed_in'] ) ) : ?>
						<p><strong>Fixed in version:</strong> <?php echo esc_html( $vuln['fixed_in'] ); ?></p>
					<?php endif; ?>
				</div>
				<?php endforeach; ?>
				<?php endif; ?>
				
				<?php if ( ! empty( $vulnerabilities['plugins'] ) ) : ?>
				<h2>Plugins</h2>
				<?php foreach ( $vulnerabilities['plugins'] as $slug => $vulns ) : ?>
					<?php foreach ( $vulns as $vuln ) : ?>
					<div class="vuln">
						<span class="severity <?php echo esc_attr( $vuln['severity'] ); ?>">
							<?php echo esc_html( strtoupper( $vuln['severity'] ) ); ?>
						</span>
						<h3><?php echo esc_html( $slug ); ?>: <?php echo esc_html( $vuln['vulnerability_title'] ); ?></h3>
						<?php if ( ! empty( $vuln['cve_id'] ) ) : ?>
							<p><strong>CVE:</strong> <?php echo esc_html( $vuln['cve_id'] ); ?></p>
						<?php endif; ?>
						<?php if ( ! empty( $vuln['fixed_in'] ) ) : ?>
							<p><strong>Fixed in version:</strong> <?php echo esc_html( $vuln['fixed_in'] ); ?></p>
						<?php endif; ?>
					</div>
					<?php endforeach; ?>
				<?php endforeach; ?>
				<?php endif; ?>
				
				<?php if ( ! empty( $vulnerabilities['themes'] ) ) : ?>
				<h2>Themes</h2>
				<?php foreach ( $vulnerabilities['themes'] as $slug => $vulns ) : ?>
					<?php foreach ( $vulns as $vuln ) : ?>
					<div class="vuln">
						<span class="severity <?php echo esc_attr( $vuln['severity'] ); ?>">
							<?php echo esc_html( strtoupper( $vuln['severity'] ) ); ?>
						</span>
						<h3><?php echo esc_html( $slug ); ?>: <?php echo esc_html( $vuln['vulnerability_title'] ); ?></h3>
						<?php if ( ! empty( $vuln['cve_id'] ) ) : ?>
							<p><strong>CVE:</strong> <?php echo esc_html( $vuln['cve_id'] ); ?></p>
						<?php endif; ?>
						<?php if ( ! empty( $vuln['fixed_in'] ) ) : ?>
							<p><strong>Fixed in version:</strong> <?php echo esc_html( $vuln['fixed_in'] ); ?></p>
						<?php endif; ?>
					</div>
					<?php endforeach; ?>
				<?php endforeach; ?>
				<?php endif; ?>
				
				<div class="footer">
					<p>Please update affected components as soon as possible.</p>
					<p><a href="<?php echo esc_url( admin_url( 'admin.php?page=wp-harden-vulnerabilities' ) ); ?>">View Full Report</a></p>
				</div>
			</div>
		</body>
		</html>
		<?php
		return ob_get_clean();
	}

	/**
	 * Schedule daily vulnerability scan
	 *
	 * @since 1.0.0
	 */
	public function schedule_scan() {
		if ( ! wp_next_scheduled( 'wph_daily_vulnerability_scan' ) ) {
			wp_schedule_event( time(), 'daily', 'wph_daily_vulnerability_scan' );
		}
	}
}
